import { useState, useEffect, useRef } from "react";
import { useSocket } from "./SocketContext";
import { useAuth } from "./AuthContext";
import Peer from "peerjs";
import { CallContext } from "./CallContextDefs";
import { getApiBase } from "../utils/apiConfig";

const API_BASE = getApiBase();


// export const useCall = ... MOVED TO CallContextDefs.js

export function CallProvider({ children }) {
  const { socket } = useSocket();
  const { user } = useAuth();
  const [activeCall, setActiveCall] = useState(null);
  const activeCallRef = useRef(null);
  const [incomingCall, setIncomingCall] = useState(null);
  /* Ref to track latest incomingCall state inside callbacks */
  const incomingCallRef = useRef(null);
  useEffect(() => { incomingCallRef.current = incomingCall; }, [incomingCall]);

  const [isCallModalOpen, setIsCallModalOpen] = useState(false);
  useEffect(() => { activeCallRef.current = activeCall; }, [activeCall]);

  const peerRef = useRef(null);
  const [peerState, setPeerState] = useState(null);
  const [myPeerId, setMyPeerId] = useState(null);
  const ringtoneRef = useRef(new Audio("/sounds/ringtone.mp3"));

  const playRingtone = () => {
    try {
      ringtoneRef.current.currentTime = 0;
      ringtoneRef.current.loop = true;
      ringtoneRef.current.play().catch((err) => console.warn("Ringtone play prevented:", err));
    } catch (error) {
      console.warn("Error acting on ringtoneRef:", error);
    }
  };

  const stopRingtone = () => { ringtoneRef.current.pause(); ringtoneRef.current.currentTime = 0; };

  useEffect(() => {
    if (!user) return;
    // Use Public PeerJS Cloud with Random ID (auto-generated by PeerJS)
    const peer = new Peer(undefined, {
      debug: 2,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:global.stun.twilio.com:3478' },
          // Add TURN servers for NAT traversal (free public TURN servers)
          {
            urls: 'turn:openrelay.metered.ca:80',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          },
          {
            urls: 'turn:openrelay.metered.ca:443',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ]
      }
    });

    peer.on('open', (id) => {
      console.log("PeerJS Connected with Random ID:", id);
      setMyPeerId(id);
      setPeerState(peer);
    });

    // Auto-Reconnect on disconnect
    peer.on('disconnected', () => {
      console.warn("PeerJS: Disconnected from signalling server. Attempting reconnect...");
      try { peer.reconnect(); } catch (e) { console.error("Reconnect failed", e); }
    });

    peer.on('close', () => {
      console.error("PeerJS: Connection closed permanently.");
      setMyPeerId(null);
    });

    peer.on('call', (call) => {
      console.log(`CallContext: Received PeerJS call from: ${call.peer}`);

      const currentActive = activeCallRef.current;
      const currentIncoming = incomingCallRef.current; // Use Ref!

      // If we are waiting for a call (socket ring received), accept this one.
      if (currentIncoming && !currentIncoming.callObject) {
        console.log("CallContext: Matched PeerJS call with Pending Socket Ring.");
        setIncomingCall(prev => ({ ...prev, callObject: call }));
        return;
      }

      if (currentActive && currentActive.type === 'p2p' && !currentActive.isIncoming && !currentActive.callObject) {
        console.log("CallContext: Matched outgoing call with incoming stream answer");
        setActiveCall(prev => ({ ...prev, callObject: call }));
        return;
      }

      // Explicitly reject/close unsolicited calls to prevent ghost connections
      if (!currentIncoming && !currentActive) {
        console.warn("CallContext: Received PeerJS call without Socket Ring! Rejecting ghost call.");
        call.close();
        return;
      }
    });

    peer.on('error', (err) => console.error("Peer Error", err));

    peerRef.current = peer;

    return () => {
      peer.destroy();
      peerRef.current = null;
      setPeerState(null);
    };
  }, [user?.uid]);

  useEffect(() => {
    if (!socket) return;

    const handleGroupRing = (data) => {
      if (activeCallRef.current) return;
      setIncomingCall({ type: 'group', from: data.from, groupId: data.groupId, groupName: data.groupName });
      setIsCallModalOpen(true);
      playRingtone();
    };

    const handleP2PRing = (data) => {
      console.log(`CallContext: Received Socket Ring from: ${data.from}`);
      if (activeCallRef.current) return;

      // 1. Immediately Acknowledge Ring (so caller knows we are ringing)
      socket.emit("ring-received", { to: data.from });

      setIncomingCall({
        type: 'p2p',
        from: data.from,
        callType: data.type, // Ensure this property is used correctly in UI
        peerId: data.peerId
      });
      setIsCallModalOpen(true);
      playRingtone();

      // AUTO-REPLY with MY Random PeerID so they can call me (or verify)
      if (peerRef.current?.id && user) {
        const myUid = user.uid.replace(/\s+/g, '_').toLowerCase();
        console.log(`CallContext: Auto-Replying with my PeerID for verification: ${peerRef.current.id} from ${myUid}`);
        socket.emit("signal-peer-id", {
          to: data.from,
          type: 'peer-id-exchange',
          payload: {
            peerId: peerRef.current.id,
            fromUid: myUid // CRITICAL: Send OUR UID so caller can verify it's us
          }
        });
      }
    };

    const handleSignal = (data) => {
      console.log(`[CallContext] Received Signal '${data.type}' from ${data.from}`, data.payload);
      if (data.type === 'peer-id-exchange') {
        const senderUid = data.payload.fromUid;
        const targetPeerId = data.payload.peerId;

        // Match against our active call's target ID
        // We check against activeCall.id (could be FC or UID)
        const currentTargetId = activeCallRef.current?.id?.toLowerCase();
        const incomingId = senderUid?.toLowerCase();

        const isMatch = activeCallRef.current && (
          currentTargetId === incomingId ||
          currentTargetId === data.from?.toLowerCase()
        );

        if (isMatch && !activeCallRef.current.targetPeerId) {
          console.log(`[CallContext] Handshake Matched! Target ID: ${currentTargetId}, PeerID: ${targetPeerId}`);
          setActiveCall(prev => ({ ...prev, targetPeerId: targetPeerId }));
        } else {
          console.warn(`[CallContext] Ignoring signal. No active match for ${incomingId || data.from}. Active: ${currentTargetId}`);
        }
      }
    };

    // NEW: Handle Ring Acknowledgment from Callee
    const handleRingReceived = () => {
      console.log("CallContext: Callee acknowledged ring. State -> RINGING");
      setActiveCall(prev => (prev ? { ...prev, callState: 'ringing' } : null));
    };

    const handleCallEnded = () => {
      stopRingtone();
      if (activeCallRef.current?.callObject) activeCallRef.current.callObject.close();
      setIncomingCall(null);
      setActiveCall(null);
      setIsCallModalOpen(false);
    };

    socket.on("incoming-group-call", handleGroupRing);
    socket.on("incoming-p2p-call", handleP2PRing);
    socket.on("signal-peer-id", handleSignal);
    socket.on("ring-received", handleRingReceived);
    socket.on("call-ended", handleCallEnded);

    return () => {
      socket.off("incoming-group-call", handleGroupRing);
      socket.off("incoming-p2p-call", handleP2PRing);
      socket.off("signal-peer-id", handleSignal);
      socket.off("ring-received", handleRingReceived);
      socket.off("call-ended", handleCallEnded);
    };
  }, [socket, user]); // Added user dependency for UID access

  const startCall = async (recipientId, type = 'audio') => {
    try {
      // Resolve canonical UID
      let targetUid = recipientId;
      try {
        const res = await fetch(`${API_BASE}/api/user/profile/${recipientId}`);
        const data = await res.json();

        if (data.success && data.user?.uid) targetUid = data.user.uid;
      } catch (e) {
        console.warn("CallContext: UID Resolve failed", e);
      }

      const sanitizedFrom = user.uid.replace(/\s+/g, '_').toLowerCase();
      // WE DO NOT KNOW TARGET PEER ID YET. WE MUST ASK.

      console.log(`CallContext: Starting Signaling to ${targetUid}...`);

      // 1. Send Ring to wake them up and ask for ID
      socket.emit("ring-user", {
        to: targetUid,
        from: sanitizedFrom,
        type,
        peerId: peerRef.current?.id // Send OUR ID so they can whistle/identify us
      });

      // 2. Open Modal in "Calling" state (waiting for ID exchange)
      setActiveCall({
        type: 'p2p',
        id: targetUid,
        isVideo: type === 'video',
        isIncoming: false,
        callState: 'dialing', // Initial State
        targetPeerId: null // WAITING FOR 'signal-peer-id' RESPONSE
      });
      setIsCallModalOpen(true);
    } catch (err) {
      console.error("CallContext: Error starting call", err);
    }
  };

  const joinGroupCall = (groupId) => {
    stopRingtone();
    setActiveCall({ type: 'group', id: groupId });
    setIsCallModalOpen(true);
    setIncomingCall(null);
  };

  const answerCall = () => {
    stopRingtone();
    if (incomingCall?.type === 'group') {
      joinGroupCall(incomingCall.groupId);
    } else if (incomingCall?.type === 'p2p') {
      setActiveCall({
        type: 'p2p',
        id: incomingCall.from,
        callObject: incomingCall.callObject,
        isIncoming: true,
        isVideo: incomingCall.callType === 'video'
      });
      setIsCallModalOpen(true);
      setIncomingCall(null);
    }
  };

  const rejectCall = () => {
    stopRingtone();
    if (incomingCall?.callObject) incomingCall.callObject.close();
    if (incomingCall?.type === 'p2p' && incomingCall.from) socket.emit("end-call", { to: incomingCall.from });
    setIncomingCall(null);
    setIsCallModalOpen(false); // CRITICAL FIX: Ensure modal closes on reject
  };

  const endCall = () => {
    stopRingtone();
    if (activeCall?.type === 'p2p' && activeCall.id) socket.emit("end-call", { to: activeCall.id });
    if (activeCall?.callObject) activeCall.callObject.close();
    setActiveCall(null);
    setIsCallModalOpen(false);
  };



  return (
    <CallContext.Provider value={{ activeCall, incomingCall, isCallModalOpen, startCall, joinGroupCall, answerCall, rejectCall, endCall, peer: peerState, myPeerId }}>
      {children}
    </CallContext.Provider>
  );
}
